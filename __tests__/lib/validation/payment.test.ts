import { describe, expect, test } from "@jest/globals";
import {
  paymentRequestSchema,
  paymentVerificationSchema,
  bip21UriSchema,
  webhookPayloadSchema,
  paymentStatusSchema,
  btcToSatoshis,
  satoshisToBtc,
  formatBtcAmount,
  isAboveDustLimit,
  generateBip21Uri,
  type PaymentRequest,
  type PaymentVerification,
  type WebhookPayload,
  type PaymentStatus,
} from "../../../src/lib/validation/payment";
import { generateWalletAddress } from "../../../src/lib/bitcoin/wallet";

describe("Payment Validation Schema", () => {
  describe("paymentRequestSchema", () => {
    describe("valid amounts", () => {
      test("should accept valid BTC amounts", () => {
        const validAmounts = [
          "0.00000546", // dust limit
          "0.001",
          "0.1",
          "1",
          "1.0",
          "1.12345678", // max decimal places
          "100",
          "10000",
        ];

        validAmounts.forEach((amount) => {
          const result = paymentRequestSchema.safeParse({ amount });
          expect(result.success).toBe(true);
          if (result.success) {
            expect(typeof result.data.amount).toBe("number");
            expect(result.data.amount).toBe(parseFloat(amount));
          }
        });
      });

      test("should transform string amounts to numbers", () => {
        const result = paymentRequestSchema.parse({ amount: "1.5" });
        expect(result.amount).toBe(1.5);
        expect(typeof result.amount).toBe("number");
      });
    });

    describe("invalid amounts", () => {
      test("should reject empty or invalid amounts", () => {
        const invalidAmounts = [
          "", // empty
          " ", // whitespace only
          "abc", // non-numeric
          "NaN", // NaN string
          "Infinity", // Infinity string
          "-1", // negative
          "0", // zero
          "0.0", // zero with decimal
        ];

        invalidAmounts.forEach((amount) => {
          const result = paymentRequestSchema.safeParse({ amount });
          expect(result.success).toBe(false);
        });
      });

      test("should reject amounts below dust limit", () => {
        const belowDustAmounts = [
          "0.00000001", // 1 satoshi
          "0.00000545", // below 546 satoshis
          "0.000001", // 100 satoshis
        ];

        belowDustAmounts.forEach((amount) => {
          const result = paymentRequestSchema.safeParse({ amount });
          expect(result.success).toBe(false);
          if (!result.success) {
            expect(result.error.errors[0].message).toContain("dust limit");
          }
        });
      });

      test("should reject amounts above maximum", () => {
        const aboveMaxAmounts = [
          "21000001", // above 21M BTC
          "100000000", // way above
        ];

        aboveMaxAmounts.forEach((amount) => {
          const result = paymentRequestSchema.safeParse({ amount });
          expect(result.success).toBe(false);
          if (!result.success) {
            expect(result.error.errors[0].message).toContain("cannot exceed");
          }
        });
      });

      test("should reject amounts with too many decimal places", () => {
        const tooManyDecimals = [
          "1.123456789", // 9 decimal places
          "0.000000001", // 9 decimal places
          "1.12345678901", // 11 decimal places
        ];

        tooManyDecimals.forEach((amount) => {
          const result = paymentRequestSchema.safeParse({ amount });
          expect(result.success).toBe(false);
          if (!result.success) {
            expect(result.error.errors[0].message).toContain("decimal places");
          }
        });
      });

      test("should reject amounts that lose precision when converted to satoshis", () => {
        // This test ensures floating point precision issues are caught
        const precisionLossAmounts = [
          "0.000000001", // below satoshi precision
        ];

        precisionLossAmounts.forEach((amount) => {
          const result = paymentRequestSchema.safeParse({ amount });
          expect(result.success).toBe(false);
        });
      });
    });
  });

  describe("paymentVerificationSchema", () => {
    test("should accept valid testnet addresses generated by our wallet", () => {
      // Generate actual valid testnet addresses using our wallet
      const address1 = generateWalletAddress();
      const address2 = generateWalletAddress("m/84'/1'/0'/0/1");
      const address3 = generateWalletAddress("m/84'/1'/0'/1/0");

      const validTestnetAddresses = [address1, address2, address3];

      validTestnetAddresses.forEach((address) => {
        const result = paymentVerificationSchema.safeParse({
          address,
          amount: "1.0",
        });
        expect(result.success).toBe(true);
      });
    });

    test("should reject invalid testnet addresses", () => {
      const invalidAddresses = [
        "", // empty
        "invalid", // invalid format
        "bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx", // mainnet address
        "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa", // mainnet legacy
        "3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy", // mainnet P2SH
        "notanaddress", // clearly invalid
        "tb1invalid", // invalid testnet format
      ];

      invalidAddresses.forEach((address) => {
        const result = paymentVerificationSchema.safeParse({
          address,
          amount: "1.0",
        });
        expect(result.success).toBe(false);
      });
    });
  });

  describe("bip21UriSchema", () => {
    test("should accept valid BIP21 URIs", () => {
      const validUris = [
        "bitcoin:tb1qd28npep0s8frcm3y7dxqajkcy2m40eysplyr9v",
        "bitcoin:tb1qd28npep0s8frcm3y7dxqajkcy2m40eysplyr9v?amount=1.5",
        "bitcoin:mjSk1Ny9spzU2fouzYgLqGUD8U41iR35QN?amount=0.001&network=testnet",
      ];

      validUris.forEach((uri) => {
        const result = bip21UriSchema.safeParse(uri);
        expect(result.success).toBe(true);
      });
    });

    test("should reject invalid BIP21 URIs", () => {
      const invalidUris = [
        "", // empty
        "https://example.com", // wrong protocol
        "bitcoin:", // no address
        "tb1qd28npep0s8frcm3y7dxqajkcy2m40eysplyr9v", // missing protocol
      ];

      invalidUris.forEach((uri) => {
        const result = bip21UriSchema.safeParse(uri);
        expect(result.success).toBe(false);
      });
    });
  });

  describe("webhookPayloadSchema", () => {
    test("should accept valid webhook payloads", () => {
      const address = generateWalletAddress();
      const validPayload = {
        event: "unconfirmed-tx",
        address,
        hash: "abc123",
        confirmations: 0,
        value: 100000000, // 1 BTC in satoshis
        double_spend: false,
      };

      const result = webhookPayloadSchema.safeParse(validPayload);
      expect(result.success).toBe(true);
    });

    test("should accept minimal webhook payloads", () => {
      const address = generateWalletAddress();
      const minimalPayload = {
        event: "confirmed-tx",
        address,
      };

      const result = webhookPayloadSchema.safeParse(minimalPayload);
      expect(result.success).toBe(true);
    });

    test("should reject invalid webhook payloads", () => {
      const invalidPayloads = [
        {}, // missing required fields
        { event: "test" }, // missing address
        { address: generateWalletAddress() }, // missing event
        {
          event: "test",
          address: "invalid-address", // invalid testnet address
        },
      ];

      invalidPayloads.forEach((payload) => {
        const result = webhookPayloadSchema.safeParse(payload);
        expect(result.success).toBe(false);
      });
    });
  });

  describe("paymentStatusSchema", () => {
    test("should accept valid payment status", () => {
      const address = generateWalletAddress();
      const validStatus = {
        status: "CONFIRMED" as const,
        address,
        amount: 1.5,
        confirmations: 6,
        transactionId: "abc123",
        timestamp: new Date(),
      };

      const result = paymentStatusSchema.safeParse(validStatus);
      expect(result.success).toBe(true);
    });

    test("should accept minimal payment status", () => {
      const address = generateWalletAddress();
      const minimalStatus = {
        status: "AWAITING_PAYMENT" as const,
        address,
        amount: 1.0,
      };

      const result = paymentStatusSchema.safeParse(minimalStatus);
      expect(result.success).toBe(true);
    });

    test("should reject invalid payment status", () => {
      const address = generateWalletAddress();
      const invalidStatuses = [
        {
          status: "INVALID_STATUS",
          address,
          amount: 1.0,
        },
        {
          status: "CONFIRMED",
          address: "invalid-address",
          amount: 1.0,
        },
        {
          status: "CONFIRMED",
          address,
          amount: -1, // invalid amount
        },
      ];

      invalidStatuses.forEach((status) => {
        const result = paymentStatusSchema.safeParse(status);
        expect(result.success).toBe(false);
      });
    });
  });
});

describe("Utility Functions", () => {
  describe("btcToSatoshis", () => {
    test("should convert BTC to satoshis correctly", () => {
      expect(btcToSatoshis(1)).toBe(100_000_000);
      expect(btcToSatoshis(0.5)).toBe(50_000_000);
      expect(btcToSatoshis(0.00000001)).toBe(1);
      expect(btcToSatoshis(0.00000546)).toBe(546);
    });

    test("should handle rounding for precision issues", () => {
      expect(btcToSatoshis(0.123456789)).toBe(12_345_679); // rounded
    });
  });

  describe("satoshisToBtc", () => {
    test("should convert satoshis to BTC correctly", () => {
      expect(satoshisToBtc(100_000_000)).toBe(1);
      expect(satoshisToBtc(50_000_000)).toBe(0.5);
      expect(satoshisToBtc(1)).toBe(0.00000001);
      expect(satoshisToBtc(546)).toBe(0.00000546);
    });
  });

  describe("formatBtcAmount", () => {
    test("should format BTC amounts correctly", () => {
      expect(formatBtcAmount(1)).toBe("1");
      expect(formatBtcAmount(1.0)).toBe("1");
      expect(formatBtcAmount(1.5)).toBe("1.5");
      expect(formatBtcAmount(1.00000001)).toBe("1.00000001");
      expect(formatBtcAmount(0.12345678)).toBe("0.12345678");
      expect(formatBtcAmount(0.123)).toBe("0.123");
    });
  });

  describe("isAboveDustLimit", () => {
    test("should correctly identify amounts above dust limit", () => {
      expect(isAboveDustLimit(0.00000546)).toBe(true); // exactly at limit
      expect(isAboveDustLimit(0.00000547)).toBe(true); // above limit
      expect(isAboveDustLimit(0.001)).toBe(true); // well above limit

      expect(isAboveDustLimit(0.00000545)).toBe(false); // below limit
      expect(isAboveDustLimit(0.00000001)).toBe(false); // well below limit
      expect(isAboveDustLimit(0)).toBe(false); // zero
    });
  });

  describe("generateBip21Uri", () => {
    test("should generate valid BIP21 URIs for testnet", () => {
      const address = generateWalletAddress();
      const amount = 1.5;

      const uri = generateBip21Uri(address, amount, "testnet");
      expect(uri).toBe(`bitcoin:${address}?amount=1.5&network=testnet`);
    });

    test("should generate valid BIP21 URIs for mainnet", () => {
      const address = "bc1qd28npep0s8frcm3y7dxqajkcy2m40eysplyr9v";
      const amount = 0.001;

      const uri = generateBip21Uri(address, amount, "mainnet");
      expect(uri).toBe(`bitcoin:${address}?amount=0.001`);
    });

    test("should default to testnet when network not specified", () => {
      const address = generateWalletAddress();
      const amount = 2.0;

      const uri = generateBip21Uri(address, amount);
      expect(uri).toBe(`bitcoin:${address}?amount=2&network=testnet`);
    });

    test("should format amounts correctly in URIs", () => {
      const address = generateWalletAddress();

      expect(generateBip21Uri(address, 1.0)).toBe(
        `bitcoin:${address}?amount=1&network=testnet`
      );
      expect(generateBip21Uri(address, 0.12345678)).toBe(
        `bitcoin:${address}?amount=0.12345678&network=testnet`
      );
      expect(generateBip21Uri(address, 0.123)).toBe(
        `bitcoin:${address}?amount=0.123&network=testnet`
      );
    });
  });
});

describe("Type Exports", () => {
  test("should export correct TypeScript types", () => {
    // This test ensures the types are correctly inferred from schemas
    const paymentRequest: PaymentRequest = { amount: 1.5 };
    expect(typeof paymentRequest.amount).toBe("number");

    const address = generateWalletAddress();
    const paymentVerification: PaymentVerification = {
      address,
      amount: 1.0,
    };
    expect(typeof paymentVerification.address).toBe("string");
    expect(typeof paymentVerification.amount).toBe("number");

    const webhookPayload: WebhookPayload = {
      event: "confirmed-tx",
      address,
    };
    expect(typeof webhookPayload.event).toBe("string");
    expect(typeof webhookPayload.address).toBe("string");

    const paymentStatus: PaymentStatus = {
      status: "CONFIRMED",
      address,
      amount: 1.0,
    };
    expect(paymentStatus.status).toBe("CONFIRMED");
    expect(typeof paymentStatus.address).toBe("string");
    expect(typeof paymentStatus.amount).toBe("number");
  });
});
